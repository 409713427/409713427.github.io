{"meta":{"title":"Wst's Blog","subtitle":"后端攻城狮","description":"","author":"ShuaiTongWang","url":"https://409713427.github.io","root":"/"},"pages":[{"title":"404","date":"2021-09-15T13:52:40.000Z","updated":"2021-09-15T13:53:21.500Z","comments":true,"path":"404/index.html","permalink":"https://409713427.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2021-09-15T13:49:50.000Z","updated":"2021-09-15T13:50:10.277Z","comments":true,"path":"about/index.html","permalink":"https://409713427.github.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-09-15T13:50:23.000Z","updated":"2021-09-15T13:50:42.853Z","comments":true,"path":"contact/index.html","permalink":"https://409713427.github.io/contact/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-09-15T13:48:30.000Z","updated":"2021-09-15T13:48:52.477Z","comments":true,"path":"categories/index.html","permalink":"https://409713427.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-09-15T13:50:55.000Z","updated":"2021-09-15T13:51:17.332Z","comments":true,"path":"friends/index.html","permalink":"https://409713427.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-15T13:49:06.000Z","updated":"2021-09-15T13:49:32.515Z","comments":true,"path":"tags/index.html","permalink":"https://409713427.github.io/tags/index.html","excerpt":"","text":""},{"title":"导航","date":"2020-05-09T03:19:14.000Z","updated":"2021-09-16T12:57:52.159Z","comments":true,"path":"navigate/index.html","permalink":"https://409713427.github.io/navigate/index.html","excerpt":"","text":""}],"posts":[{"title":"Java基础 【继承，引用类型使用】","slug":"Java基础 【继承，引用类型使用】","date":"2021-09-17T12:02:32.000Z","updated":"2021-09-17T15:15:32.529Z","comments":true,"path":"2021/091736523.html","link":"","permalink":"https://409713427.github.io/2021/091736523.html","excerpt":"","text":"Java基础 【继承，引用类型使用】第一章 继承1.1 定义​ 继承就是子类继承父类的属性和行为，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为 1.2 继承的好处 1. 提高**代码的复用性**（减少代码冗余，相同代码重复利用）。 2. 使类与类之间产生了关系。 1.3 子类不能继承的内容1.3.1 引入并不是父类的所有内容都可以给子类继承的： 子类不能继承父类的构造器，因为子类有自己的构造器。 值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。 1.3.2 演示代码public class Demo03 { public static void main(String[] args) { Zi z = new Zi(); System.out.println(z.num1); // System.out.println(z.num2); // 私有的子类无法使用 // 通过getter/setter方法访问父类的private成员变量 System.out.println(z.getNum2()); z.show1(); // z.show2(); // 私有的子类无法使用 } } class Fu { public int num1 = 10; private int num2 = 20; public void show1() { System.out.println(\"show1\"); } private void show2() { System.out.println(\"show2\"); } public int getNum2() { return num2; } public void setNum2(int num2) { this.num2 = num2; } } class Zi extends Fu { } 小贴士：父类中的成员变量是非私有的，子类中可以直接访问。若父类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx()方法和setXxx()方法。 1.4 方法重写1.4.1 概念方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 1.4.2使用场景与案例发生在子父类之间的关系。子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方 法。 例如：我们定义了一个动物类代码如下： public class Animal { public void run(){ System.out.println(\"动物跑的很快！\"); } public void cry(){ System.out.println(\"动物都可以叫~~~\"); } } 然后定义一个猫类，猫可能认为父类cry()方法不能满足自己的需求 代码如下： public class Cat extends Animal { public void cry(){ System.out.println(\"我们一起学猫叫，喵喵喵！喵的非常好听！\"); } } public class Test { public static void main(String[] args) { // 创建子类对象 Cat ddm = new Cat()； // 调用父类继承而来的方法 ddm.run(); // 调用子类重写的方法 ddm.cry(); } } 1.4.3 @Override重写注解 @Override:注解，重写注解校验！ 这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。 建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！ 加上后的子类代码形式如下： public class Cat extends Animal { // 声明不变，重新实现 // 方法名称与父类全部一样，只是方法体中的功能重写写了！ @Override public void cry(){ System.out.println(\"我们一起学猫叫，喵喵喵！喵的非常好听！\"); } } 1.4.4 注意事项 方法重写是发生在子父类之间的关系。 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。 1.5 this与super 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。 super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 super(..)和this(…)是根据参数去确定调用父类哪个构造器的。 super(..)可以调用父类构造器初始化继承自父类的成员变量的数据。 this(..)可以调用本类中的其他构造器。 第二章 引用类型使用总结实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的。在这我们使用两个例子 , 来学习一下。 2.1 引用类型作为方法参数和返回值public class Person{ public void eat(){ System.out.println(\"吃饭\"); } } public class Test{ public static void main(String[] args){ method(new Person()); Person p = createPerson(); } //引用类型作为方法参数,在前面笔记本案例中我们也使用了接口类型作为方法参数 pubic static void method(Person p){ p.eat(); } //引用类型作为返回值 public static Person createPerson(){ return new Person(); } } 2.2 引用类型作为成员变量​ 我们每个人(Person)都有一个身份证(IDCard) , 为了表示这种关系 , 就需要在Person中定义一个IDCard的成员变量。定义Person类时，代码如下： class Person { String name;//姓名 int age;//年龄 } ​ 使用使用String 类型表示姓名 , int 类型表示年龄。其实，String本身就是引用类型，我们往往忽略了它是引用类型。如果我们继续丰富这个类的定义，给Person 增加身份证号 , 身份证签发机关等属性，我们将如何编写呢？这时候就需要编写一个IDCard类了 定义IDCard(身份证)类，添加身份证号 , 签发地等属性： class IDCard { String idNum;//身份证号 String authority;//签发地 //getter和setter方法 //... //toString方法 //... } 修改Person类： public class Person { String name;//姓名 int age;//年龄 IDCard idCard;//表示自己的身份证信息 //name和age的getter、setter方法 //... public IDCard getIdCard() { return idCard; } public void setIdCard(IDCard idCard) { this.idCard = idCard; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", idCard=\" + idCard + '}'; } } 测试类： public class TestDemo { public static void main(String[] args) { //创建IDCard对象 IDCard idCard = new IDCard(); //设置身份证号 idCard.setIdNum(\"110113201606066666\"); //设置签发地 idCard.setAuthority(\"北京市顺义区公安局\"); //创建Person对象 Person p = new Person(); //设置姓名 p.setName(\"小顺子\"); //设置年龄 p.setAge(2); //设置身份证信息 p.setIdCard(idCard); //打印小顺子的信息 System.out.println(p); } } 输出结果: Person{name='小顺子', age=2, idCard=IDCard{idNum='110113201606066666', authority='北京市顺义区公安局'}} 类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。同理 , 接口也是如此 , 例如我们笔记本案例中使用usb设备。在此我们只是通过小例子 , 让大家熟识下引用类型的用法 , 后续在咱们的就业班学习中 , 这种方式会使用的很多。","categories":[{"name":"java","slug":"java","permalink":"https://409713427.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://409713427.github.io/tags/java/"}],"author":"wst"},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-09-16T05:22:43.000Z","updated":"2021-09-17T05:48:05.769Z","comments":true,"path":"2021/091615650.html","link":"","permalink":"https://409713427.github.io/2021/091615650.html","excerpt":"我的博客文章编写","text":"我的博客文章编写 标题使用标题时候需要写# 这是第一个段落 这是第二个段落 区块引用 这是一段高亮显示 超链接 百度 图片","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-09-15T11:20:52.891Z","updated":"2021-09-16T09:35:37.612Z","comments":true,"path":"2021/091516107.html","link":"","permalink":"https://409713427.github.io/2021/091516107.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"https://409713427.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://409713427.github.io/tags/java/"}]}