{"meta":{"title":"Wst's Blog","subtitle":"后端攻城狮","description":"","author":"ShuaiTongWang","url":"https://409713427.github.io","root":"/"},"pages":[{"title":"404","date":"2021-09-15T13:52:40.000Z","updated":"2021-09-15T13:53:21.500Z","comments":true,"path":"404/index.html","permalink":"https://409713427.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2021-09-15T13:49:50.000Z","updated":"2021-09-15T13:50:10.277Z","comments":true,"path":"about/index.html","permalink":"https://409713427.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-09-15T13:48:30.000Z","updated":"2021-09-15T13:48:52.477Z","comments":true,"path":"categories/index.html","permalink":"https://409713427.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-09-15T13:50:23.000Z","updated":"2021-09-15T13:50:42.853Z","comments":true,"path":"contact/index.html","permalink":"https://409713427.github.io/contact/index.html","excerpt":"","text":""},{"title":"导航","date":"2020-05-09T03:19:14.000Z","updated":"2021-09-16T12:57:52.159Z","comments":true,"path":"navigate/index.html","permalink":"https://409713427.github.io/navigate/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-09-15T13:50:55.000Z","updated":"2021-09-15T13:51:17.332Z","comments":true,"path":"friends/index.html","permalink":"https://409713427.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-15T13:49:06.000Z","updated":"2021-09-15T13:49:32.515Z","comments":true,"path":"tags/index.html","permalink":"https://409713427.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【JS新特性系列】ES6新增属性Symbol详解","slug":"js新特性/ES6新增属性Symbol详解","date":"2021-10-27T08:25:32.000Z","updated":"2021-10-27T04:37:34.419Z","comments":true,"path":"2021/102719592.html","link":"","permalink":"https://409713427.github.io/2021/102719592.html","excerpt":"","text":"ES6新增属性Symbol详解1.什么Symbol?Symbol是ES6中新增的一种数据类型, 被划分到了基本数据类型中基本数据类型: 字符串、数值、布尔、undefined、null、Symbol引用数据类型: Object 2.Symbol的作用用来表示一个独一无二的值 3.如果生成一个独一无二的值?let xxx = Symbol(); 4.为什么需要Symbol?在企业开发中如果需要对一些第三方的插件、框架进行自定义的时候可能会因为添加了同名的属性或者方法, 将框架中原有的属性或者方法覆盖掉为了避免这种情况的发生, 框架的作者或者我们就可以使用Symbol作为属性或者方法的名称 5.如何区分Symbol?在通过Symbol生成独一无二的值时可以设置一个标记这个标记仅仅用于区分, 没有其它任何含义 let obj = { name: \"lnj\", say: function () { console.log(\"say\"); } } obj.name = \"it666\"; console.log(obj.name); //it666 原值被覆盖 obj.say = function () { console.log(\"test\"); } obj.say();//test 原方法被覆盖 //解决方案: 用symbol let name = Symbol(\"name\"); let say = Symbol(\"say\"); let obj = { // 注意点: 如果想使用变量作为对象属性的名称, 那么必须加上[] [name]: \"lnj\", [say]: function () { console.log(\"say\"); } } // obj.name = \"it666\"; obj[Symbol(\"name\")] = \"it666\"; console.log(obj); 6.symbol注意点通过Symbol生成独一无二值时需要在后面加上(), 但是前面不能加new, 因为它不是引用类型 let xxx = Symbol(); // 正确 let xxx = new Symbol(); // 错误 通过Symbol生成独一无二值时传入的字符串仅仅是一个标记, 方便我们阅读代码, 没有其它任何意义 let xxx = Symbol(\"name\"); 做类型转换的时候不能转换成数值 let xxx = Symbol(\"name\"); console.log(String(xxx)); console.log(Boolean(xxx)); console.log(Number(xxx)); 不能做任何运算 let xxx = Symbol(\"name\"); console.log(xxx + \"abc\"); //报错 console.log(xxx + 123); //报错 Symbol生成的值作为属性或方法名称时, 一定更要保存下来, 否则后续无法使用 let name = Symbol(\"name\"); let obj = { // [name]: \"lnj\" [Symbol(\"name\")]: \"it666\" } // console.log(obj[name]); console.log(obj[Symbol(\"name\")]); for循环无法遍历出Symbol的属性和方法 let name = Symbol(\"name\"); let say = Symbol(\"say\"); let obj = { // 注意点: 如果想使用变量作为对象属性的名称, 那么必须加上[] [name]: \"lnj\", [say]: function () { console.log(\"say\"); }, age: 34, gender: \"man\", hi: function () { console.log(\"hi\"); } } // for(let key in obj){ // console.log(key); // } console.log(Object.getOwnPropertySymbols(obj));","categories":[{"name":"javascript","slug":"javascript","permalink":"https://409713427.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://409713427.github.io/tags/javascript/"}],"author":"wst"},{"title":"【JS新特性系列】Generator函数与async函数","slug":"js新特性/Generator函数与async函数","date":"2021-10-27T04:35:32.000Z","updated":"2021-10-27T04:37:34.425Z","comments":true,"path":"2021/102724586.html","link":"","permalink":"https://409713427.github.io/2021/102724586.html","excerpt":"","text":"Generator函数与async函数1.什么是Generator函数?Generator 函数是 ES6 提供的一种异步编程解决方案Generator 函数内部可以封装多个状态, 因此又可以理解为是一个状态机 2.如何定义Generator函数只需要在普通函数的function后面加上*即可 3.Generator函数和普通函数区别3.1调用Generator函数后, 无论函数有没有返回值, 都会返回一个迭代器对象,3.2调用Generator函数后, 函数中封装的代码不会立即被执行 4.真正让Generator具有价值的是yield关键字4.1在Generator函数内部使用yield关键字定义状态4.2并且yield关键字可以让 Generator内部的逻辑能够切割成多个部分。4.3通过调用迭代器对象的next方法执行一个部分代码,执行哪个部分就会返回哪个部分定义的状态 5.在调用next方法的时候可以传递一个参数, 这个参数会传递给上一个yieldfunction* gen() { console.log(\"123\"); let res = yield \"aaa\"; console.log(res); console.log(\"567\"); yield 1 + 1; console.log(\"789\"); yield true; } let it = gen(); // console.log(it); console.log(it.next()); console.log(it.next(\"it666\")); // console.log(it.next()); // console.log(it.next()); // 注意点: yield关键字只能在Generator函数中使用, 不能在普通函数中使用 // function say() { // yield \"abc\"; // } // say(); 应用场景1.让函数返回多个值 /* function calculate(a, b) { let sum = a + b; let sub = a - b; return [sum, sub]; } */ function* calculate(a, b) { yield a + b; yield a - b; } let it = calculate(10, 5); console.log(it.next().value); console.log(it.next().value); 2.用同步的流程来表示异步的操作 /* 回调地狱实现 function request(fn) { setTimeout(function () { fn(\"拿到的数据\"); }, 1000); } request(function (data) { console.log(\"1\", data); request(function (data) { console.log(\"2\", data); request(function (data) { console.log(\"3\", data); }); }); }); */ function request() { return new Promise(function (resolve, reject) { setTimeout(function () { resolve(\"拿到的数据\"); }, 1000); }); } /* promise实现 request().then(function (data) { console.log(data, 1); return request(); }).then(function (data) { console.log(data, 2); return request(); }).then(function (data) { console.log(data, 3); }); */ //Generator实现 function* gen() { yield request(); yield request(); yield request(); } let it = gen(); // console.log(it.next().value); it.next().value.then(function (data) { console.log(data, 1); return it.next().value; }).then(function (data) { console.log(data, 2); return it.next().value; }).then(function (data) { console.log(data, 3); }); 3.利用 Generator 函数，可以在任意对象上快速部署 Iterator 接口 /* Generator 函数特点 1.Generator 函数也是一个函数 2.Generator 函数会返回一个迭代器对象 3.迭代器对象有next方法 4.next方法每次执行都会返回一个对象{value: xxx, done: false} */ /* function* gen() { yield \"aaa\"; yield \"bbb\"; yield \"ccc\"; } let it = gen(); // console.log(it); console.log(it.next()); */ /* 1.必须有一个叫做[Symbol.iterator]的属性 2.[Symbol.iterator]的属性会返回一个函数 3.[Symbol.iterator]返回的函数执行之后会返回一个可迭代对象 4.[Symbol.iterator]函数返回的对象中又一个名称叫做next的方法 5.next方法每次执行都会返回一个对象{value: xxx, done: false} */ /* let obj = { name: \"lnj\", age: 34, gender: \"man\", [Symbol.iterator](){ let keys = Object.keys(this); // console.log(keys); let index = 0; let that = this; return { next(){ if(index &lt; keys.length){ return {value: that[keys[index++]], done: false}; }else{ return {value: undefined, done: true}; } } } } } // console.log(obj[Symbol.iterator]); // let it = obj[Symbol.iterator](); // console.log(it); // console.log(it.next()); // console.log(it.next()); // console.log(it.next()); // console.log(it.next()); for(let value of obj){ console.log(value); } */ let obj = { name: \"lnj\", age: 34, gender: \"man\" } function* gen(){ let keys = Object.keys(obj); for(let i = 0; i &lt; keys.length; i++){ yield obj[keys[i]]; } } obj[Symbol.iterator] = gen; // console.log(obj[Symbol.iterator]); let it = obj[Symbol.iterator](); // console.log(it); console.log(it.next()); console.log(it.next()); console.log(it.next()); console.log(it.next()); 6.async函数async函数是ES8中新增的一个函数, 用于定义一个异步函数async函数函数中的代码会自动从上至下的执行代码 7.await操作符await操作符只能在异步函数 async function 中使用await表达式会暂停当前 async function 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，然后继续执行 async function。 function request() { return new Promise(function (resolve, reject) { setTimeout(function () { resolve(\"拿到的数据\"); }, 1000); }); } /* function* gen() { yield request(); yield request(); yield request(); } let it = gen(); it.next().value.then(function (data) { console.log(data, 1); return it.next().value; }).then(function (data) { console.log(data, 2); return it.next().value; }).then(function (data) { console.log(data, 3); }); */ async function gen() { let res1 = await request(); console.log(res1, 1); let res2 = await request(); console.log(res2, 2); let res3 = await request(); console.log(res3, 3); } gen();","categories":[{"name":"javascript","slug":"javascript","permalink":"https://409713427.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://409713427.github.io/tags/javascript/"}],"author":"wst"},{"title":"【JS新特性系列】ES6 Promise总结","slug":"js新特性/ES6中 Promise总结","date":"2021-10-27T04:25:32.000Z","updated":"2021-10-27T04:37:34.424Z","comments":true,"path":"2021/102715630.html","link":"","permalink":"https://409713427.github.io/2021/102715630.html","excerpt":"","text":"ES6中 Promise总结提示:如果你还不太懂js中的同步代码和异步代码 请参考此扩展阅读 1.什么是PromisePromise 是ES6中新增的异步编程解决方案，在代码中的表现是一个对象. // 需求: 从网络上加载3个资源, 要求加载完资源1才能加载资源2, 加载完资源2才能加载资源3 // 前面任何一个资源加载失败, 后续资源都不加载 function request(fn) { setTimeout(function () { fn(\"拿到的数据\"); }, 1000); } request(function (data) { console.log(data, 1); request(function (data) { console.log(data, 2); request(function (data) { console.log(data, 3); }); }); }); /* 2.promise作用 企业开发中为了保存异步代码的执行顺序, 那么就会出现回调函数层层嵌套 如果回调函数嵌套的层数太多, 就会导致代码的阅读性, 可维护性大大降低 promise对象可以将异步操作以同步流程来表示, 避免了回调函数层层嵌套(回调地狱) */ function request() { return new Promise(function (resolve, reject) { setTimeout(function () { resolve(\"拿到的数据\"); }, 1000); }); } request().then(function (data) { console.log(data, 1); return request(); }).then(function (data) { console.log(data, 2); return request(); }).then(function (data) { console.log(data, 3); }); 2.Promise的基本使用 什么是Promise? Promise是ES6中新增的一个对象,通过Promise就可以实现 用同步的流程来表示异步的操作通过Promise就可以 避免回调函数层层嵌套(回调地狱)问题 如何创建Promise对象? new Promise(function(resolve, reject){});promise对象不是异步的, 只要创建promise对象就会立即执行存放的代码 Promise是如何实现 通过同步的流程来表示异步的操作的? promise对象是通过状态的改变来实现的, 只要状态发生改变就会自动触发对应的函数 Promise对象三种状态 pending: 默认状态，只要没有告诉promise任务是成功还是失败就是pending状态fulfilled(resolved): 只要调用resolve函数, 状态就会变为fulfilled, 表示操作成功rejected: 只要调用rejected函数, 状态就会变为rejected, 表示操作失败注意点: 状态一旦改变既不可逆, 既从pending变为fulfilled, 那么永远都是fulfilled 即从pending变为rejected, 那么永远都是rejected 监听Promise状态改变 可以通过函数来监听状态的变化resolved –&gt; then()rejected –&gt; catch() let promise = new Promise(function (resolve, reject) { console.log(\"1\"); reject(); // resolve(); }); promise.then(function () { console.log(\"then\"); }); promise.catch(function () { console.log(\"catch\"); }); 3.then方法详解then方法接收两个参数,第一个参数是状态切换为成功时的回调,第二个参数是状态切换为失败时的回调 let promise = new Promise(function (resolve, reject) { // resolve(); // 将状态修改为成功 reject(); // 将状态修改为失败 }); promise.then(function () { console.log(\"成功\"); }, function () { console.log(\"失败\"); }); then方法在修改promise状态时, 可以传递参数给then方法中的回到函数 // resolve = success, reject = error; let promise = new Promise(function (resolve, reject) { // resolve(\"111\"); // 将状态修改为成功 success(\"111\"); reject(\"aaa\"); // 将状态修改为失败 error(\"aaa\"); }); // promise.then(function (data) { // console.log(\"成功\", data); // }, function (data) { // console.log(\"失败\", data); // }); function success(data) { console.log(data); } function error(data) { console.log(data); } promise.then(success, error); then方法同一个promise对象可以多次调用then方法,当该promise对象的状态时所有then方法都会被执行 let promise = new Promise(function (resolve, reject) { // resolve(); // 将状态修改为成功 reject(); // 将状态修改为失败 }); promise.then(function () { console.log(\"成功1\"); }, function () { console.log(\"失败1\"); }); promise.then(function () { console.log(\"成功2\"); }, function () { console.log(\"失败2\"); }); then方法then方法每次执行完毕后会返回一个新的promise对象 let promise = new Promise(function (resolve, reject) { resolve(); // 将状态修改为成功 // reject(); // 将状态修改为失败 }); let p2 = promise.then(function () { console.log(\"成功1\"); }, function () { console.log(\"失败1\"); }); console.log(p2); console.log(promise === p2);//false then方法可以通过上一个promise对象的then方法给下一个promise对象的then方法传递参数注意点:无论是在上一个promise对象成功的回调还是失败的回调传递的参数,都会传递给下一个promise对象成功的回调 let promise = new Promise(function (resolve, reject) { // resolve(\"111\"); // 将状态修改为成功 reject(\"aaa\"); // 将状态修改为失败 }); let p2 = promise.then(function (data) { console.log(\"成功1\", data); return \"222\"; }, function (data) { console.log(\"失败1\", data); return \"bbb\"; }); p2.then(function (data) { console.log(\"成功2\", data); }, function (data) { console.log(\"失败2\", data); }); then方法如果then方法返回的是一个Promise对象, 那么会将返回的Promise对象的执行结果中的值传递给下一个then方法 let promise = new Promise(function (resolve, reject) { resolve(\"111\"); // 将状态修改为成功 // reject(\"aaa\"); // 将状态修改为失败 }); let ppp = new Promise(function (resolve, reject) { // resolve(\"222\"); // 将状态修改为成功 reject(\"bbb\"); // 将状态修改为失败 }); let p2 = promise.then(function (data) { console.log(\"成功1\", data); return ppp; }, function (data) { console.log(\"失败1\", data); return \"bbb\"; }); p2.then(function (data) { console.log(\"成功2\", data); }, function (data) { console.log(\"失败2\", data); }); catch方法详解catch方法与then方法所讲的注意点基本一致,以下只说出catch独有的注意点 /* 0.catch方法 catch 其实是 then(undefined, () => {}) 的语法糖 * */ let promise = new Promise(function (resolve, reject) { // resolve(); // 将状态修改为成功 reject(); // 将状态修改为失败 }); promise.catch(function () { console.log(\"abc\"); }); /* 2.catch方法 注意点: 如果需要分开监听, 也就是通过then监听成功通过catch监听失败 那么必须使用链式编程, 否则会报错 * */ let promise = new Promise(function (resolve, reject) { // resolve(); // 将状态修改为成功 reject(); // 将状态修改为失败 }); promise.then(function () { console.log(\"成功\"); }).catch(function () { console.log(\"失败\"); }); /* 报错 promise.then(function () { console.log(\"成功\"); }); promise.catch(function () { console.log(\"失败\"); }); */ /* 3.catch方法 不使用链式编程的原因是 1.如果promise的状态是失败, 但是没有对应失败的监听就会报错 2.then方法会返回一个新的promise, 新的promise会继承原有promise的状态 3.如果新的promise状态是失败, 但是没有对应失败的监听也会报错 * */ let promise = new Promise(function (resolve, reject) { // resolve(); // 将状态修改为成功 reject(); // 将状态修改为失败 }); let p2 = promise.then(function () { console.log(\"成功\"); }); console.log(p2); promise.catch(function () { console.log(\"失败1\"); }); p2.catch(function () { console.log(\"失败2\"); }); /* 6.catch方法 和then方法第二个参数的区别在于, catch方法可以捕获上一个promise对象then方法中的异常 * */ let promise = new Promise(function (resolve, reject) { resolve(); }); // promise.then(function () { // console.log(\"成功\"); // xxx // }, function () { // console.log(\"失败\"); // }); promise.then(function () { console.log(\"成功\"); xxx }).catch(function (e) { console.log(\"失败\", e); }); promise应用场景练习/* 需求: 一次加载一张图片添加到body中. 前面图片加载失败后面图片不加载 */ let arr = [ \"http://www.xxx.com/picture_1.png\", \"http://www.xxx.com/picture_2.png\", \"http://wwww.xxx.com/files/picture_3.png\" ]; function loadImage(url) { return new Promise(function (resolve, reject) { let oImg = new Image(); oImg.src = url; oImg.onload = function () { resolve(oImg); } oImg.onerror = function () { reject(\"图片加载失败\"); } }); } loadImage(arr[0]).then(function (oImg) { // console.log(oImg); console.log(\"1\"); document.body.appendChild(oImg); return loadImage(arr[1]); }).then(function (oImg) { console.log(\"2\"); // console.log(oImg); document.body.appendChild(oImg); return loadImage(arr[2]); }).then(function (oImg) { console.log(\"3\"); // console.log(oImg); document.body.appendChild(oImg); }).catch(function (msg) { console.log(msg); }); promise-all方法Promise的all静态方法:1.all方法接收一个数组,2.如果数组中有多个Promise对象,只有都成功才会执行then方法,并且会按照添加的顺序, 将所有成功的结果重新打包到一个数组中返回给我们.3.如果数组中不是Promise对象, 那么会直接执行then方法 应用场景: 批量加载, 要么一起成功, 要么一起失败 练习: /* 需求: 无序加载图片, 只有所有图片都加载成功才添加, 有一张图片失败都不添加 */ let arr = [ \"http://www.xxx.com/picture_1.png\", \"http://www.xxx.com/picture_2.png\", \"http://wwww.xxx.com/files/picture_3.png\" ]; function loadImage(url) { return new Promise(function (resolve, reject) { let oImg = new Image(); let time = Math.random() * 1000; // console.log(time); setTimeout(function () { oImg.src = url; }, time); // oImg.src = url; oImg.onload = function () { resolve(oImg); } oImg.onerror = function () { reject(\"图片加载失败了\"); } }); } Promise.all([loadImage(arr[0]), loadImage(arr[1]),loadImage(arr[2])]) .then(function (result) { // console.log(result); result.forEach(function (oImg) { document.body.appendChild(oImg); }); }) .catch(function (e) { console.log(e); }); promise-race方法Promise的race静态方法:1.all方法接收一个数组,2.如果数组中有多个Promise对象, 谁先返回状态就听谁的, 后返回的会被抛弃3.如果数组中不是Promise对象, 那么会直接执行then方法 应用场景: 接口调试, 超时处理 场景模拟: let url = \"http://www.xxx.com/picture_1.png\"; function loadImage(url) { return new Promise(function (resolve, reject) { let oImg = new Image(); setTimeout(function () { oImg.src = url; }, 5000); oImg.onload = function () { resolve(oImg); } oImg.onerror = function () { reject(\"图片加载失败了\"); } }); } function timeout() { return new Promise(function (resolve, reject) { setTimeout(function () { reject(\"超时了\"); }, 3000); }); } Promise.race([loadImage(url), timeout()]).then(function (value) { console.log(\"成功\", value); }).catch(function (e) { console.log(\"失败\", e); });","categories":[{"name":"javascript","slug":"javascript","permalink":"https://409713427.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://409713427.github.io/tags/javascript/"}],"author":"wst"},{"title":"【JS新特性系列】ajax,fetch,axios之间的详细区别以及优缺点","slug":"js新特性/ajax,fetch,axios之间的详细区别以及优缺点","date":"2021-10-26T02:25:32.000Z","updated":"2021-10-27T04:37:34.427Z","comments":true,"path":"2021/102634377.html","link":"","permalink":"https://409713427.github.io/2021/102634377.html","excerpt":"","text":"ajax,fetch,axios之间的详细区别以及优缺点将jQuery的ajax、axios和fetch做个简单的比较，所谓仁者见仁智者见智，最终使用哪个还是自行斟酌 1.jQuery ajax$.ajax({ type: 'POST', url: url, data: data, dataType: dataType, success: function () {}, error: function () {} }); 优缺点： 本身是针对MVC的编程,不符合现在前端MVVM的浪潮基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务） 2.fetch和Ajax一样都是用于请求网络数据的fetch是ES6中新增的, 基于Promise的网络请求方法 fetch(\"http://127.0.0.1/jQuery/Ajax/xx.php\", { method: \"post\", body: JSON.stringify({teacher:\"hhh\", age:666}) }).then(function (res) { //res是response对象 // console.log(res.text()); //.text()返回promise对象 // return res.text(); return res.json(); }).then(function (data) { console.log(data); console.log(typeof data); }).catch(function (e) { console.log(e); }); 优缺点： 符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里更好更方便的写法更加底层，提供的API丰富（request, response）脱离了XHR，是ES规范里新的实现方式1）fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理2）fetch默认不会带cookie，需要添加配置项3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费4）fetch没有办法原生监测请求的进度，而XHR可以 3.axiosAxios 是一个基于 promise 的 HTTP 库网络请求插件. /* 3.全局的 axios 默认值 在企业开发中项目分为 :开发阶段和部署阶段, 这两个阶段项目存储的位置是不同的 项目上线前存储在企业内部测试服务器上, 项目上线后存储在企业正式服务器上 所以如果每次请求都将请求的地址写在请求中, 那么项目上线时需要大量修改请求地址 为了解决这个问题, 我们可以配置一个全局URL根地址, 项目上线时只需要修改根地址即可 例如: 上线前地址是: http://127.0.0.1/jQuery/Ajax/xx.php 上线后地址是: http://192.199.13.14/jQuery/Ajax/xx.php */ axios.defaults.timeout = 2000; axios.defaults.baseURL = \"http://127.0.0.1\"; axios.post(\"/jQuery/Ajax/xx.php\", { teacher: \"lnj\", age: 666 }) .then(function (res) { console.log(res.data); }) .catch(function (e) { console.log(e); }); 优缺点： 从 node.js 创建 http 请求 支持 Promise API 客户端支持防止CSRF 自动转换JSON数据 提供了一些并发请求的接口（重要，方便了很多的操作） 为什么要用axios?axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest从 node.js 发出 http 请求支持 Promise API拦截请求和响应转换请求和响应数据取消请求自动转换JSON数据客户端支持防止CSRF/XSRF","categories":[{"name":"javascript","slug":"javascript","permalink":"https://409713427.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://409713427.github.io/tags/javascript/"}],"author":"wst"},{"title":"【JS新特性系列】H5新增存储方案有以及同源跨域访问请求","slug":"js新特性/同源与跨域访问请求","date":"2021-10-25T04:35:32.000Z","updated":"2021-10-27T04:37:34.428Z","comments":true,"path":"2021/102545839.html","link":"","permalink":"https://409713427.github.io/2021/102545839.html","excerpt":"","text":"JS新特性H5新增存储方案1.SessionStorage和LocalStorage简介 和Cookie一样, SessionStorage和LocalStorage也是用于存储网页中的数据的 2.Cookie、 SessionStorage、LocalStorage区别 2.1生命周期(同一浏览器下) Cookie生命周期: 默认是关闭浏览器后失效, 但是也可以设置过期时间 SessionStorage生命周期: 仅在当前会话(窗口)下有效，关闭窗口或浏览器后被清除, 不能设置过期时间 LocalStorage生命周期: 除非被清除，否则永久保存 ​ 2.2容量​ Cookie容量: 有大小(4KB左右)和个数(20~50)限制​ SessionStorage容量: 有大小限制(5M左右) 老外写的SessionStorage支撑测试​ LocalStorage容量: 有大小限制(5M左右) 老外写的LocalStorage支撑测试 ​ 2.3网络请求​ Cookie网络请求: 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题​ SessionStorage网络请求: 仅在浏览器中保存，不参与和服务器的通信​ LocalStorage网络请求: 仅在浏览器中保存，不参与和服务器的通信 3.Cookie、 SessionStorage、LocalStorage应用场景 Cookie: 判断用户是否登录 LocalStorage: 购物车 sessionStorage: 表单数据 4.注意点: 无论通过以上哪种方式存储的数据, 切记不能将敏感数据直接存储到本地 示例: // 存储cookie document.cookie = \"myName=hhh;path=/;domain=127.0.0.1;\"; //存储sessionStorage,删除sessionStorage,清空sessionStorage sessionStorage.setItem(\"age\", \"34\"); sessionStorage.removeItem(\"age\"); sessionStorage.clear(); //存储localStorage,删除localStorage,清空localStorage localStorage.setItem(\"name\", \"lnj\"); localStorage.removeItem(\"name\"); localStorage.clear(); 同源策略1.什么是同源策略? 同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能 所谓同源是指: 协议，域名，端口都相同,就是同源, 否则就是跨域 ​ http://www.baidu.com:80/index.html​ 协议: http/https/…​ 一级域名: baidu.com/taobao.com​ 二级域名: www/study/edu/…​ 端口号: 80/3306/… // 协议+一级域名+二级域名+端口号都相同, 所以同源 http://www.it666.com:80/index.html http://www.it666.com:80/detail.html // 协议不同, 所以不同源, 是跨域 http://www.it666.com:80/index.html https://www.it666.com:80/index.html // 一级域名不同, 所以不同源, 是跨域 http://www.it666.com:80/index.html http://www.itzb.com:80/index.html // 二级域名不同, 所以不同源, 是跨域 http://www.it666.com:80/index.html http://edu.it666.com:80/index.html // 端口号不同, 所以不同源, 是跨域 http://www.it666.com:80/index.html http://www.it666.com:8090/index.html //ajax默认同源 $.ajax({ url:\"http://127.0.0.1:80/jQuery/Ajax/xxx.php\", success: function (msg) { console.log(msg); }, error: function () { console.log(\"请求失败\"); } }); 2.同源策略带来的影响 在同源策略下, 浏览器只允许Ajax请求同源的数据, 不允许请求不同源的数据 但在企业开发中, 一般情况下为了提升网页的性能, 网页和数据都是单独存储在不同服务器上的 这时如果再通过Ajax请求数据就会拿不到跨域数据 3.跨域解决方案(除第一种 剩下的基本不用了) jsonp document.domain+iframe location.hash + iframe window.name + iframe window.postMessage flash等第三方插件 JSONP 什么是JSONP?JSONP让网页从别的地址（跨域的地址）那获取资料，即跨域读取数据 JSONP实现跨域访问的原理2.1 在同一界面中可以定义多个script标签2.2 同一个界面中多个script标签中的数据可以相互访问2.3 可以通过script的src属性导入其它资源2.4 通过src属性导入其它资源的本质就是将资源拷贝到script标签中2.5 script的src属性不仅能导入本地资源, 还能导入远程资源2.6 由于script的src属性没有同源限制, 所以可以通过script的src属性来请求跨域数据 &lt;script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"> &lt;script src=\"http://127.0.0.1:80/jQuery/Ajax/xx.php\"> /* 当前网页的地址: http://127.0.0.1:63342/jQuery/Ajax/jsonp%E5%8E%9F%E7%90%86.html 远程资源的地址: http://127.0.0.1:80/jQuery/Ajax/jsonp.php */ /* 优化一 1.在企业开发中通过JSONP来获取跨域的数据, 一般情况下服务器返回的都不会是一个变量, 而是一个函数的调用 */ /* 优化二 2.当前服务器返回的函数调用名称写死了 例如服务前返回demo() ,那么本地就必须有一个 服务器返回函数叫什么名称, 我们本地就必须定义一个叫什么名称的函数 解决方案: 通过URL参数的方式来动态指定函数名称 例:http://127.0.0.1:80/jQuery/Ajax/20-jsonp.php?cb=test cb=test就是指定返回的函数调用名为test,后台获取到就可以定义一个test方法返回 */ /* 优化三 3.由于script标签默认是同步, 前面的script标签没有加载完数据, 后面的script标签就不会被执行 所以请求数据的script标签必须放到后面 解决方案: 通过JS动态创建script标签, 因为JS动态创建的script标签默认就是异步的, 不用等到前面的标签加载完就可以执行后面的script标签 */ let oScript = document.createElement(\"script\"); oScript.src = \"http://127.0.0.1:80/jQuery/Ajax/20-jsonp.php?cb=test\"; document.body.appendChild(oScript); jQuery中jsonp使用$.ajax({ url: \"http://127.0.0.1:80/jQuery/Ajax/jsonp.php\", data:{ \"name\": \"wst\", \"age\": 21 }, dataType: \"jsonp\", // 告诉jQuery需要请求跨域的数据 jsonp: \"cb\", // 告诉jQuery服务器在获取回调函数名称的时候需要用什么key来获取 jsonpCallback: \"wst\", // 告诉jQuery服务器在获取回调函数名称的时候回调函数的名称是什么 success: function (msg) { console.log(msg); } }); jQuery封装JSONP原理//自己封装的jsonp function obj2str(obj) { // 生成随机因子 obj.t = (Math.random() + \"\").replace(\".\", \"\"); let arr = []; for(let key in obj){ arr.push(key + \"=\" + encodeURI(obj[key])); } let str = arr.join(\"&amp;\"); // console.log(str); return str; } function myJSONP(options) { options = options || {}; // http://127.0.0.1/jQuery/Ajax/jsonp.php?cb=wst&amp;name=wst&amp;age=21&amp;_=1559735634387 // http://127.0.0.1/jQuery/Ajax/jsonp.php?cb=wst&amp;name=wst&amp;age=21&amp;t=08520581619221432 // 1.生成URL地址 let url = options.url; if(options.jsonp){ url += \"?\" + options.jsonp + \"=\"; }else{ url += \"?callback=\"; } let callbackName = (\"jQuery\" + Math.random()).replace(\".\", \"\"); if(options.jsonpCallback){ callbackName = options.jsonpCallback; url += options.jsonpCallback; }else{ // console.log(callbackName); url += callbackName; } if(options.data){ let str = obj2str(options.data); url += \"&amp;\" + str; } // console.log(url); // 2.获取跨域的数据 let oScript = document.createElement(\"script\"); oScript.src = url; document.body.appendChild(oScript); // 3.定义回调函数 window[callbackName] = function (data) { // 删除已经获取了数据的script标签 document.body.removeChild(oScript); // 将获取到的数据返回给外界 options.success(data); } } //调用自己定义的jsonp myJSONP({ url: \"http://127.0.0.1:80/jQuery/Ajax/jsonp.php\", data:{ \"name\": \"wst\", \"age\": 21 }, jsonp: \"cb\", // 告诉jQuery服务器在获取回调函数名称的时候需要用什么key来获取 jsonpCallback: \"wst\", // 告诉jQuery服务器在获取回调函数名称的时候回调函数的名称是什么 success: function (msg) { console.log(msg); } });","categories":[{"name":"javascript","slug":"javascript","permalink":"https://409713427.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://409713427.github.io/tags/javascript/"}],"author":"wst"},{"title":"【Linux安装插件系列】Linux安装配置tomcat9.0","slug":"Linux服务器上安装tomcat","date":"2021-10-21T05:40:32.000Z","updated":"2021-10-21T05:54:07.928Z","comments":true,"path":"2021/102136523.html","link":"","permalink":"https://409713427.github.io/2021/102136523.html","excerpt":"","text":"Linux服务器上安装tomcat 安装软件 ： apache-tomcat-9.0.0.M1.tar.gz（下载地址http://tomcat.apache.org/） 步骤一 Tomcat是其中一个开源的且免费的java Web服务器，是Apache软件基金会的项目，所以安装Tomcat之前要安装java JDk，请参照Linux安装jdk1.8 步骤二 下载Tomcat9 ​ 将文件移动到apache-tomcat-9.0.0.M1.tar.gz移动到/usr/tomcat/下，并解压： 解压命令 : tar -xzvf apache-tomcat-10.0.12.tar.gz 并修改文件名 mv apache-tomcat-10.0.12 apache-tomcat-10.0.12-8082 再次解压apache-tomcat-10.0.12.tar.gz 文件，并修改解压后的文件价名为apache-tomcat-10.0.12-8082，得到 ​ 步骤三 修改端口，分别修改tomcat里面conf/server.xml server.xml文件中有三个端口设置 &lt;Server port=\"8005\" shutdown=\"SHUTDOWN\"> ：关闭时使用 &lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /> ： 一般应用使用 &lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />：为AJP端口，即容器使用，如 APACHE能通过AJP协议访问Tomcat的8009端口 第一个80的tomcat的三个端口分别修改为：8005/80/8009 第二个8082的tomcat的三个端口分别修改为：7082/8082/9082 步骤四 启动tomcat，分别进入tomcat里面的bin目录 执行： ./startup.sh –&gt;启动tomcat 执行： ./shutdown.sh –&gt;关闭tomcat 浏览器中输入：http://ip:80 和http://ip:8082（ip指服务器的IP地址），即可访问不同的tomcat 步骤五 设置tomcat开机启动 1、找到/etc文件夹下的rc.local文件（有的是在/etc/rc.d文件夹下），在文件的最后添加以下java环境变量和启动tomcat命令： export JAVA_HOME=/home/wst/jdk1.8 export JRE_HOME=$JAVA_HOME/jre sh /home/wst/Documents/tomcat10/apache-tomcat-10.0.12-80/bin/startup.sh（启动命令，可以配置条） 保存退出 :wq 2、给rc.local文件添加执行权限 chmod +x rc.local 3、重启服务器，即可访问Tomcat reboot","categories":[{"name":"linux","slug":"linux","permalink":"https://409713427.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://409713427.github.io/tags/linux/"}],"author":"wst"},{"title":"【Linux安装插件系列】Linux安装配置jdk1.8","slug":"Linux安装jdk1.8","date":"2021-10-19T05:30:32.000Z","updated":"2021-10-21T05:54:06.762Z","comments":true,"path":"2021/101936523.html","link":"","permalink":"https://409713427.github.io/2021/101936523.html","excerpt":"","text":"Linux安装jdk1.8第一次再Linux安装jdk并且配置环境,为了以后查看,在这里记录一下. linux 下安装jdk和windows下的安装是一样的，之前在windows安装的时候是先下载压缩包，然后再配置环境变量。其实在linux下也是一样的。 第一步：创建jdk安装目录(该/usr/local/src 目录是空的,最好把我们自己下载的放到这,容易区分)命令： mkdir -p /usr/local/src/jdk 第二步：查看安装程序命令：rpm -qa | grep -i jdk 若之前安装过jdk，下次安装一定把之前的删除干净 第三步：下载jdk包需要联网，下载也需要点时间）此次使用的为后缀为tar.gz的文件（不需要安装），如jdk-8u131-linux-x64.tar.gz 安装指令: [root@master wst]# wget --no-check-certificate --no-cookies --header \"Cookie: oraclelicense=accept-securebackup-cookie\" http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz 注意：如果上面wget命令不能用,报错：-bash: wget: command not found。执行一下该命令(安装依赖包) yum -y install wget 注意 : 记住需要加上：–no-check-certificate –no-cookies –header “Cookie: oraclelicense=accept-securebackup-cookie” 这段是为了避开用户验证用的 第四步：解压解压命令 : tar -zxvf jdk-8u131-linux-x64.tar.gz 系统会生成一个名为：jdk1.8.0_131 的文件夹。可以使用mv命令自定义文件名。 更改文件夹名称 : mv jdk1.8.0_131 jdk1.8 第五步：配置环境变量 编辑配置文件: vi /etc/profile 可以看到这个文件的内容，profile文件有点类似于windows系统里面的环境变量的配置， shift + g 定位到最后一行 这个时候按一下a或i键，进入编辑模式 export JAVA_HOME=/usr/local/src/jdk/jdk1.8 export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 第六步：退出文件，保存​ 按Esc键 输入:wq 保存并退出 第七步：让配置文件生效# source /etc/profile 第八步：查看是否配置成功[root@master wst]# java -version 若出现jdk版本号，则安装并配置环境变量成功 ​ 如果提示命令找不到的话，查看一下jdk的配置路径是否错误。","categories":[{"name":"linux","slug":"linux","permalink":"https://409713427.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://409713427.github.io/tags/linux/"}],"author":"wst"},{"title":"【Linux安装插件系列】Linux安装配置mysql8.0","slug":"Linux-CentOS7安装mysql8.0","date":"2021-10-15T05:35:32.000Z","updated":"2021-10-21T05:58:54.781Z","comments":true,"path":"2021/101536523.html","link":"","permalink":"https://409713427.github.io/2021/101536523.html","excerpt":"","text":"Linux-CentOS7安装mysql8.0密码策略： https://blog.csdn.net/Hello_World_QWP/article/details/79551789 CentOS7安装mysql8.0步骤1.1 安装前清理工作,第一次安装请忽略； 1.1.1 清理原有的mysql数据库； 使用以下命令查找出安装的mysql软件包和依赖包： rpm -pa | grep mysql 显示结果如下： mysql80-community-release-el7-1.noarch mysql-community-server-8.0.11-1.el7.x86_64 mysql-community-common-8.0.11-1.el7.x86_64 mysql-community-libs-8.0.11-1.el7.x86_64 mysql-community-client-8.0.11-1.el7.x86_64 使用以下命令依次删除上面的程序 yum remove mysql-xxx-xxx- 删除mysql的配置文件，卸载不会自动删除配置文件，首先使用如下命令查找出所用的配置文件； find / -name mysql 可能的显示结果如下： /etc/logrotate.d/mysql /etc/selinux/targeted/active/modules/100/mysql /etc/selinux/targeted/tmp/modules/100/mysql /var/lib/mysql /var/lib/mysql/mysql /usr/bin/mysql /usr/lib64/mysql /usr/local/mysql 根据需求使用以下命令 依次 对配置文件进行删除 rm -rf /var/lib/mysql 1.1.2 删除MariaDB的文件，由于MySQL在CentOS7中收费了，所以已经不支持MySQL了，取而代之在CentOS7内部集成了mariadb，而安装MySQL的话会和MariaDB的文件冲突，所以需要先卸载掉MariaDB. 使用rpm 命令查找出要删除的mariadb文件； rpm -pa | grep mariadb 可能的显示结果如下： mariadb-libs-5.5.56-2.el7.x86_64 rpm -e mariadb-libs-5.5.56-2.el7.x86_64 #删除上面的程序 可能出现错误提示如下： 依赖检测失败： libmysqlclient.so.18()(64bit) 被 (已安裝) postfix-2:2.10.1-6.el7.x86_64 需要 libmysqlclient.so.18(libmysqlclient_18)(64bit) 被 (已安裝) postfix-2:2.10.1-6.el7.x86_64 需要 libmysqlclient.so.18(libmysqlclient_18)(64bit) 被 (已安裝) postfix-2:2.10.1-6.el7.x86_64 需要 使用强制删除： rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64 至此就将原来有的mysql 和mariadb数据库删除了； 1.2 安装mysql1.2.1 下面mysql官网提供的mysql repo源 centos的yum 源中默认是没有mysql的，所以我们需要先去官网下载mysql的repo源并安装； mysql官网下载链接：mysql repo下载地址 如下：https://dev.mysql.com/downloads/ 1.2.2 下载软件包rpm文件文件下载到home/wst/Documents/mysql8.0文件夹下； cd home/wst/Documents mkdir mysql8.0 cd mysql8.0 wget https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm 1.2.3 安装 yum repo文件并更新 yum 缓存；rpm -ivh mysql80-community-release-el7-1.noarch.rpm 执行结果： 会在/etc/yum.repos.d/目录下生成两个repo文件mysql-community.repo mysql-community-source.repo 更新 yum 命令 yum clean all yum makecache 1.2.4 使用 yum安装mysql当我们在使用yum安装mysql时，yum默认会从yum仓库中安装mysql最新的GA版本；如何选择自己的版本； 第一步： 查看mysql yum仓库中mysql版本，使用如下命令 yum repolist all | grep mysql 可以看到 MySQL 5.5 5.6 5.7为禁用状态 而MySQL 8.0为启用状态； 第二步 使用 yum-config-manager 命令修改相应的版本为启用状态最新版本为禁用状态，根据需要安装的版本修改 yum-config-manager --disable mysql80-community #关闭8.0版本 yum-config-manager --enable mysql57-community #开启5.7版本 或者可以编辑 mysql repo文件， cat /etc/yum.repos.d/mysql-community.repo 将相应版本下的enabled改成 1 即可； 1.2.5 安装mysql 命令如下：yum install mysql-community-server 1.2.6 开启mysql 服务systemctl start mysqld.service 1.2.7 获取初始密码登录mysqlmysql在安装后会创建一个root@locahost账户，并且把初始的密码放到了/var/log/mysqld.log文件中； cat /var/log/mysqld.log | grep password 使用初始密码登录mysql jKw)wB/&lt;X4?z mysql -u root -p #会提示输入密码 修改初始密码：ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!';#注意位数和种类至少大+写+小写+符号+数字 忘记密码重置密码[重置密码解决MySQL for Linux错误 ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES)] vim /etc/my.cnf #注：windows下修改的是my.ini skip-grant-tables# 在[mysqld]后面任意一行添加skip-grant-tables用来跳过密码验证的过程;设置完密码记得删除 systemctl restart mysqld.service #重启mysql ，就可以免密码登陆了，然后进行修改密码 1.2.8 在防火墙中开启3306端口CentOS7默认使用的是firewall作为防火墙，我这里改为习惯常用的iptables防火墙 第一步：开启firewall3306端口防火墙 firewall-cmd --zone=public --list-ports 查看所有打开的端口 firewall-cmd --zone=public --add-port=80/tcp --permanent 开启一个端口，添加--permanent永久生效，没有此参数重启后失效 firewall-cmd --permanent --add-port=80/tcp 开放端口80 firewall-cmd --permanent --remove-port=80/tcp 移除端口80 firewall-cmd --reload 重启防火墙，修改后重启防火墙生效 第五步： 重启防火墙 systemctl enable iptables.service systemctl start iptables.service 1.2.9 将mysql 服务加入开机启动项，并启动mysql进程 systemctl enable mysqld.service systemctl start mysqld.service 常用mysql服务命令： mysql -u username -p #登录mysql quit #退出mysql systemctl start mysqld.service #启动mysql systemctl stop mysqld.service #结束 systemctl restart mysqld.service #重启 systemctl enable mysqld.service #开机自启 select version(); #查看mysql版本 2.1 开启mysql远程服务：外网 Navicat 连接 Mysql 2.1.1 修改mysql数据库下的user表中host的值可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”登录mysql数据库 执行如下命令： mysql -u root -p use mysql; update user set host='%' where user='root'; 2.1.2 使用授权的方式赋予任何主机访问数据的权限 mysql> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%'WITH GRANT OPTION; mysql>FLUSH PRIVILEGES 如果想myuser用户使用mypassword密码从任何主机连接到mysql服务器的话。 GRANT ALL PRIVILEGES ON *.* TO 'myuser'@'%'IDENTIFIED BY 'mypassword' WITH GRANT OPTION; 如果你想允许用户myuser从ip为192.168.1.6的主机连接到mysql服务器，并使用mypassword作为密码 GRANT ALL PRIVILEGES ON *.* TO 'myuser'@'192.168.1.3'IDENTIFIED BY 'mypassword' WITH GRANT OPTION; 2.2 在使用 Navicat for Mysql连接mysql 8.0时会报如下错误：Authentication plugin ‘caching_sha2_password’ cannot be loaded: mysql8.0 引入了新特性 caching_sha2_password；这种密码加密方式客户端不支持；客户端支持的是mysql_native_password 这种加密方式； 我们可可以查看mysql 数据库中user表的 plugin字段； 可以使用命令将他修改成mysql_native_password加密模式： update user set plugin='mysql_native_password' where user='root'; 再用Navicat链接 就可以链接成功； 安装过程中涉及到的Linux命令学习； 3.1 rpm 3.2 putty 上传文件 pscp命令； 在window机上CD进入pttty安装目录： cd :\\program files (x86)\\Putty 将本地文件拷贝到Linux上：pscp 文件 用户名@LinuxIP:目录 pscp hello.txt root@192.168.145.135:/tmp/userfile/ 将本地文件夹 拷贝到Linux上：pscp -r 目录 用户名@LinuxIP:目录 pscp -r c:\\file root@10.43.65.98:/root/testFolder 将Linux上的文件\\root\\test.txt拷贝到本地C盘src文件夹，如下： pscp root@abc_pc:/root/test.txt C:\\src 3.3 修改防火墙文件/etc/sysconfig/iptables 3.4 systemctl命令 授权外网登陆 1。 改表法。 可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改成”%” Sql代码 1. mysql -u root -pvmwaremysql>use mysql; 2. mysql>update user set host = '%' where user = 'root'; 3. mysql>select host, user from user; 授权法。 例如，你想myuser使用mypassword从任何主机连接到mysql服务器的话。 Sql代码 GRANT ALL PRIVILEGES ON *.* TO 'myuser'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION; FLUSH PRIVILEGES; 如果你想允许用户myuser从ip为192.168.1.6的主机连接到mysql服务器的dk数据库，并使用mypassword作为密码 Sql代码 GRANT ALL PRIVILEGES ON dk.* TO 'myuser'@'192.168.1.3' IDENTIFIED BY 'mypassword' WITH GRANT OPTION; FLUSH PRIVILEGES; 注意授权后必须FLUSH PRIVILEGES;否则无法立即生效。 3 另外一种方法. 在安装mysql的机器上运行： 1、d:\\mysql\\bin\\>mysql -h localhost -u root //这样应该可以进入MySQL服务器 2、mysql>GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION //赋予任何主机访问数据的权限 3、mysql>FLUSH PRIVILEGES //修改生效 4、mysql>EXIT //退出MySQL服务器 这样就可以在其它任何的主机上以root身份登录啦！ 其它： mysql> grant all privileges on *.* to 'energy_pf'@'192.168.2.65' identified by 'energy_pf' with grant option; Query OK, 0 rows affected (0.00 sec) mysql> plush privileges; #立即生效 允许用户energy_pf从ip为192.168.2.65的主机连接到mysql服务器的任意数据库（*.*），并使用energy_pf作为密码","categories":[{"name":"linux","slug":"linux","permalink":"https://409713427.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://409713427.github.io/tags/linux/"}],"author":"wst"},{"title":"java基础【抽象类，接口、代码块、final、单例、枚举】","slug":"day02-抽象类，接口、代码块、final、单例、枚举","date":"2021-09-19T12:02:32.000Z","updated":"2021-10-21T05:33:56.009Z","comments":true,"path":"2021/091936523.html","link":"","permalink":"https://409713427.github.io/2021/091936523.html","excerpt":"","text":"java基础【抽象类，接口、代码块、final、单例、枚举】第一章 抽象类1.1 概述1.1.1 抽象类引入父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类完全只需要提供一个没有方法体的方法签名即可，具体实现交给子类自己去实现。我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。 抽象方法 ： 没有方法体的方法。 抽象类：包含抽象方法的类。 1.2 abstract使用格式abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。 1.2.1 抽象方法使用abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。 定义格式： 修饰符 abstract 返回值类型 方法名 (参数列表)； 代码举例： public abstract void run()； 1.2.2 抽象类如果一个类包含抽象方法，那么该类必须是抽象类。注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。 定义格式： abstract class 类名字 { } 代码举例： public abstract class Animal { public abstract void run()； } 1.2.3 抽象类的使用要求：继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。 代码举例： // 父类,抽象类 abstract class Employee { private String id; private String name; private double salary; public Employee() { } public Employee(String id, String name, double salary) { this.id = id; this.name = name; this.salary = salary; } // 抽象方法 // 抽象方法必须要放在抽象类中 abstract public void work(); } // 定义一个子类继承抽象类 class Manager extends Employee { public Manager() { } public Manager(String id, String name, double salary) { super(id, name, salary); } // 2.重写父类的抽象方法 @Override public void work() { System.out.println(\"管理其他人\"); } } // 定义一个子类继承抽象类 class Cook extends Employee { public Cook() { } public Cook(String id, String name, double salary) { super(id, name, salary); } @Override public void work() { System.out.println(\"厨师炒菜多加点盐...\"); } } // 测试类 public class Demo10 { public static void main(String[] args) { // 创建抽象类,抽象类不能创建对象 // 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象 // Employee e = new Employee(); // e.work(); // 3.创建子类 Manager m = new Manager(); m.work(); Cook c = new Cook(\"ap002\", \"库克\", 1); c.work(); } } 此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。 1.3 抽象类的特征抽象类的特征总结起来可以说是 有得有失 有得：抽象类得到了拥有抽象方法的能力。 有失：抽象类失去了创建对象的能力。 其他成员（构造器，实例方法，静态方法等）抽象类都是具备的。 1.4 抽象类的注意事项关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。 抽象类中，可以有构造器，是供子类创建对象时，初始化父类成员使用的。 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。 抽象类存在的意义是为了被子类继承，抽象类体现的是模板思想。 理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。 1.5 抽象类存在的意义抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义，抽象类体现的是模板思想，模板是通用的东西抽象类中已经是具体的实现（抽象类中可以有成员变量和实现方法），而模板中不能决定的东西定义成抽象方法，让使用模板（继承抽象类的类）的类去重写抽象方法实现需求，这是典型的模板思想。 1.6 第一个设计模式：模板模式我们现在使用抽象类设计一个模板模式的应用，例如在小学的时候，我们经常写作文，通常都是有模板可以套用的。假如我现在需要定义新司机和老司机类，新司机和老司机都有开车功能，开车的步骤都一样，只是驾驶时的姿势有点不同，新司机:开门,点火,双手紧握方向盘,刹车,熄火，老司机:开门,点火,右手握方向盘左手抽烟,刹车,熄火。我们可以将固定流程写到父类中，不同的地方就定义成抽象方法，让不同的子类去重写，代码如下: // 司机开车的模板类 public abstract class Driver { public void go() { System.out.println(\"开门\"); System.out.println(\"点火\"); // 开车姿势不确定?定义为抽象方法 ziShi(); System.out.println(\"刹车\"); System.out.println(\"熄火\"); } public abstract void ziShi(); } 现在定义两个使用模板的司机： public class NewDriver extends Driver { @Override public void ziShi() { System.out.println(\"新司机双手紧握方向盘\"); } } public class OldDriver extends Driver { @Override public void ziShi() { System.out.println(\"老司机右手握方向盘左手抽烟...\"); } } 编写测试类 public class Demo02 { public static void main(String[] args) { NewDriver nd = new NewDriver(); nd.go(); OldDriver od = new OldDriver(); od.go(); } } 可以看出，模板模式的优势是，模板已经定义了通用架构，使用者只需要关心自己需要实现的功能即可！非常的强大！ 第二章 接口2.1 概述我们已经学完了抽象类，抽象类中可以用抽象方法，也可以有普通方法，已经构造器，成员变量等。那么什么是接口呢？接口是更加彻底的抽象，接口中全部是抽象方法。（JDK8之前），接口同样是不能创建对象的。 2.2 定义格式//接口的定义格式： 修饰符 interface 接口名称{ // 抽象方法 } // 修饰符：public|缺省 // 接口的声明：interface // 接口名称：首字母大写，满足“驼峰模式” 2.3 接口成分的特点 在JDK8之前，接口中的成分包含：抽象方法和常量 2.3.1.抽象方法​ 注意：接口中的抽象方法默认会自动加上public abstract修饰程序员无需自己手写！！​ 按照规范：以后接口中的抽象方法建议不要写上public abstract。因为没有必要啊，默认会加上。 2.3.2 常量 在接口中定义的成员变量默认会加上： public static final修饰。也就是说在接口中定义的成员变量实际上是一个常量。这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。常量必须要给初始值。常量命名规范建议字母全部大写，多个单词用下划线连接。 2.3.3 案例演示public interface InterF { // 抽象方法！ // public abstract void run(); void run(); // public abstract String getName(); String getName(); // public abstract int add(int a , int b); int add(int a , int b); // 它的最终写法是： // public static final int AGE = 12 ; int AGE = 12; //常量 String SCHOOL_NAME = \"黑马程序员\"; } 2.4 基本的实现2.4.1 实现接口的概述类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements关键字。 2.4.2 实现接口的格式/**接口的实现： 在Java中接口是被实现的，实现接口的类称为实现类。 实现类的格式:*/ [修饰符] class 类名 implements 接口1,接口2,接口3...{ } 从上面格式可以看出，接口是可以被多实现的。大家可以想一想为什么呢？ 2.4.3 类实现接口的要求和意义 必须重写实现的全部接口中所有抽象方法。 如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。 意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。 2.4.4 类与接口基本实现案例假如我们定义一个运动员的接口（规范），代码如下： /** 接口：接口体现的是规范。 * */ public interface SportMan { void run(); // 抽象方法，跑步。 void law(); // 抽象方法，遵守法律。 String compittion(String project); // 抽象方法，比赛。 } 接下来定义一个乒乓球运动员类，实现接口，实现接口的实现类代码如下： package com.itheima._03接口的实现; /** * 接口的实现： * 在Java中接口是被实现的，实现接口的类称为实现类。 * 实现类的格式: * [修饰符] class 类名 implements 接口1,接口2,接口3...{ * * * } * */ public class PingPongMan implements SportMan { @Override public void run() { System.out.println(\"乒乓球运动员稍微跑一下！！\"); } @Override public void law() { System.out.println(\"乒乓球运动员守法！\"); } @Override public String compittion(String project) { return \"参加\"+project+\"得金牌！\"; } } 测试代码： public class TestMain { public static void main(String[] args) { // 创建实现类对象。 PingPongMan zjk = new PingPongMan(); zjk.run(); zjk.law(); System.out.println(zjk.compittion(\"全球乒乓球比赛\")); } } 1.4.5 类与接口的多实现案例类与接口之间的关系是多实现的，一个类可以同时实现多个接口。 首先我们先定义两个接口，代码如下： /** 法律规范：接口*/ public interface Law { void rule(); } /** 这一个运动员的规范：接口*/ public interface SportMan { void run(); } 然后定义一个实现类： /** * Java中接口是可以被多实现的： * 一个类可以实现多个接口: Law ,SportMan * * */ public class JumpMan implements Law ,SportMan { @Override public void rule() { System.out.println(\"尊长守法\"); } @Override public void run() { System.out.println(\"训练跑步！\"); } } 从上面可以看出类与接口之间是可以多实现的，我们可以理解成实现多个规范，这是合理的。 2.5 接口与接口的多继承Java中，接口与接口之间是可以多继承的：也就是一个接口可以同时继承多个接口。大家一定要注意： 类与接口是实现关系 接口与接口是继承关系 接口继承接口就是把其他接口的抽象方法与本接口进行了合并。 案例演示： public interface Abc { void go(); void test(); } /** 法律规范：接口*/ public interface Law { void rule(); void test(); } * * 总结： * 接口与类之间是多实现的。 * 接口与接口之间是多继承的。 * */ public interface SportMan extends Law , Abc { void run(); } 2.6 JDK 8之后的接口新增方法从JDK 8开始之后，接口不再纯洁了，接口中不再只是抽象方法，接口还可以有默认方法（也就是实例方法），和静态方法了，还包含了私有实例方法和私有静态方法 2.6.1 含有默认方法和静态方法默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。 静态方法：使用 static 修饰，供接口直接调用。 代码如下： public interface InterFaceName { public default void method() { // 执行语句 } public static void method2() { // 执行语句 } } 2.6.2 含有私有方法和私有静态方法私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。 代码如下： public interface InterFaceName { private void method() { // 执行语句 } } 2.6.3 新增方法的使用默认方法和静态方法以及私有方法和私有静态方法，遵循面向对象的继承关系使用原则，实现类依然可以访问接口的非私有方法，对于接口中的非私有静态方法，可以直接通过接口名进行访问。 重写默认方法注意（了解）: 子接口重写默认方法时，default关键字可以保留。 实现类重写默认方法时，default关键字不可以保留。 2.7 实现多个接口使用注意事项2.7.1 多个接口同名静态方法如果实现了多个接口，多个接口中存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。 public interface A { public static void test(){ } } interface B { public static void test(){ } } class C implements A , B{ public static void main(String[] args) { People.test(); B.test(); // C.test(); // 编译出错 } } 2.7.2 优先级的问题当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。代码如下： 定义接口： interface A { public default void methodA(){ System.out.println(\"AAAAAAAAAAAA\"); } } 定义父类： class D { public void methodA(){ System.out.println(\"DDDDDDDDDDDD\"); } } 定义子类： class C extends D implements A { // 未重写methodA方法 } 定义测试类： public class Test { public static void main(String[] args) { C c = new C(); c.methodA(); } } 输出结果: DDDDDDDDDDDD 2.8 接口小结 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。 接口中的方法全是抽象方法，默认会自动加上public abstract修饰 JDK 8开始，接口不再纯洁，支持静态方法，默认方法，私有方法。 接口中，没有构造器，不能创建对象。 类与接口是多实现的 接口与接口是多继承的 接口体现的规范。 第三章 代码块3.1 引入类的成分：​ 1.成员变量​ 2.构造器​ 3.成员方法​ 4.代码块​ 5.内部类 我们已经学完了成员变量，构造器，成员方法，接下来我们来介绍以下代码快，代码块按照有无static可以分为静态代码块和实例代码块。 3.2 静态代码块静态代码块​ 必须有static修饰，必须放在类下。与类一起加载执行。 格式 static{ // 执行代码 } 特点： 每次执行类，加载类的时候都会先执行静态代码块一次。 静态代码块是自动触发执行的，只要程序启动静态代码块就会先执行一次。 作用：在启动程序之前可以做资源的初始化，一般用于初始化静态资源。 案例演示 public class DaimaKuaiDemo01 { public static String sc_name ; // 1.静态代码块 static { // 初始化静态资源 sc_name = \"黑马程序员！\"; System.out.println(\"静态代码块执行！\"); } public static void main(String[] args) { System.out.println(\"main方法执行\"); System.out.println(sc_name); } } 3.3 实例代码块实例代码块​ 没有static修饰，必须放在类下。与对象初始化一起加载。 格式 { // 执行代码 } 特点： 无static修饰。属于对象，与对象的创建一起执行的。 每次调用构造器初始化对象，实例代码块都要自动触发执行一次。 实例代码块实际上是提取到每一个构造器中去执行的。 作用：实例代码块用于初始化对象的资源。 案例演示 public class DaimaKuaiDemo02 { private String name ; // 实例代码块。 无static修饰。 { System.out.println(\"实例代码块执行\"); name = \"dl\"; } // 构造器 public DaimaKuaiDemo02(){ //System.out.println(\"实例代码块执行\"); } // 有参数构造器 public DaimaKuaiDemo02(String name){ //System.out.println(\"实例代码块执行\"); } public static void main(String[] args) { // 匿名对象，创建出来没有给变量。 new DaimaKuaiDemo02(); new DaimaKuaiDemo02(); new DaimaKuaiDemo02(\"xulei\"); } } // 输出三次：实例代码块执行 常用API 第四章 final关键字4.1 概述学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了final 关键字，用于修饰不可改变内容。 final： 不可改变，最终的含义。可以用于修饰类、方法和变量。 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，有且仅能被赋值一次。 4.2 使用方式4.2.1 修饰类final修饰的类，不能被继承。 格式如下： final class 类名 { } 代码: final class Fu { } // class Zi extends Fu {} // 报错,不能继承final的类 查询API发现像 public final class String 、public final class Math 、public final class Scanner 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。 4.2.2 修饰方法final修饰的方法，不能被重写。格式如下： 修饰符 final 返回值类型 方法名(参数列表){ //方法体 } 代码: class Fu2 { final public void show1() { System.out.println(\"Fu2 show1\"); } public void show2() { System.out.println(\"Fu2 show2\"); } } class Zi2 extends Fu2 { // @Override // public void show1() { // System.out.println(\"Zi2 show1\"); // } @Override public void show2() { System.out.println(\"Zi2 show2\"); } } 4.2.3 修饰变量-局部变量 局部变量——基本类型基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下： public class FinalDemo1 { public static void main(String[] args) { // 声明变量，使用final修饰 final int a; // 第一次赋值 a = 10; // 第二次赋值 a = 20; // 报错,不可重新赋值 // 声明变量，直接赋值，使用final修饰 final int b = 10; // 第二次赋值 b = 20; // 报错,不可重新赋值 } } 思考，如下两种写法，哪种可以通过编译？ 写法1： final int c = 0; for (int i = 0; i &lt; 10; i++) { c = i; System.out.println(c); } 写法2： for (int i = 0; i &lt; 10; i++) { final int c = i; System.out.println(c); } 根据 final 的定义，写法1报错！写法2，为什么通过编译呢？因为每次循环，都是一次新的变量c。这也是大家需要注意的地方。 4.2.4 修饰变量-实例成员变量成员变量涉及到初始化的问题，初始化方式有显示初始化和构造器初始化，只能选择其中一个： 显示初始化(在定义成员变量的时候立马赋值)； public class Student { final int num = 10; } 构造器初始化(在构造器中赋值一次)。 注意：每个构造器中都要赋值一次！ public class Student { final int num = 10; final int num2; public Student() { this.num2 = 20; // this.num2 = 20; } public Student(String name) { this.num2 = 20; // this.num2 = 20; } } 被final修饰的常量名称，一般都有书写规范，所有字母都大写。 第五章 单例设计模式正常情况下一个类可以创建多个对象 public static void main(String[] args) { // 正常情况下一个类可以创建多个对象 Person p1 = new Person(); Person p2 = new Person(); Person p3 = new Person(); } 5.1 单例设计模式的作用单例模式，是一种常用的软件设计模式。通过单例模式可以保证系统中，应用该模式的这个类只有一个实例。即一个类只有一个对象实例。 5.2 单例设计模式实现步骤 将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。 定义一个静态方法返回这个唯一对象。 5.3 单例设计模式的类型根据实例化对象的时机单例设计模式又分为以下两种: 饿汉单例设计模式 懒汉单例设计模式 5.4 饿汉单例设计模式饿汉单例设计模式就是使用类的时候已经将对象创建完毕，不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故被称为“饿汉模式”。 代码如下： public class Singleton { // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 private Singleton() {} // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。 private static final Singleton instance = new Singleton(); // 3.定义一个静态方法返回这个唯一对象。 public static Singleton getInstance() { return instance; } } 5.5 懒汉单例设计模式懒汉单例设计模式就是调用getInstance()方法时实例才被创建，先不急着实例化出对象，等要用的时候才例化出对象。不着急，故称为“懒汉模式”。 代码如下： public class Singleton { // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。 private static Singleton instance; // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 private Singleton() {} // 3.定义一个静态方法返回这个唯一对象。要用的时候才例化出对象 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 注意：懒汉单例设计模式在多线程环境下可能会实例化出多个对象，不能保证单例的状态。我们在学习完多线程的时候还会再讲解如何解决这个问题。 5.6 小结单例模式可以保证系统中一个类只有一个对象实例。 实现单例模式的步骤： 将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。 定义一个静态方法返回这个唯一对象。 第六章 枚举6.1 不使用枚举存在的问题假设我们要定义一个人类，人类中包含姓名和性别。通常会将性别定义成字符串类型，效果如下： public class Person { private String name; private String sex; public Person() { } public Person(String name, String sex) { this.name = name; this.sex = sex; } // 省略get/set/toString方法 } public class Demo01 { public static void main(String[] args) { Person p1 = new Person(\"张三\", \"男\"); Person p2 = new Person(\"张三\", \"abc\"); // 因为性别是字符串,所以我们可以传入任意字符串 } } 不使用枚举存在的问题：可以给性别传入任意的字符串，导致性别是非法的数据，不安全。 6.2 枚举的作用与应用场景枚举的作用：一个方法接收的参数是固定范围之内的时候，那么即可使用枚举。 6.3 枚举的基本语法6.3.1 枚举的概念枚举是一种特殊类。枚举是有固定实例个数的类型，我们可以把枚举理解成有固定个数实例的多例模式。 6.3.2 定义枚举的格式enum 枚举名 { 第一行都是罗列枚举实例,这些枚举实例直接写大写名字即可。 } 6.3.3 入门案例 定义枚举：BOY表示男，GIRL表示女 enum Sex { BOY, GIRL; // 男，女 } Perosn中的性别有String类型改为Sex枚举类型 public class Person { private String name; private Sex sex; public Person() { } public Person(String name, Sex sex) { this.name = name; this.sex = sex; } // 省略get/set/toString方法 } 使用是只能传入枚举中的固定值 public class Demo02 { public static void main(String[] args) { Person p1 = new Person(\"张三\", Sex.BOY); Person p2 = new Person(\"张三\", Sex.GIRL); Person p3 = new Person(\"张三\", \"abc\"); } } 5.3.4 枚举的其他内容枚举的本质是一个类，我们刚才定义的Sex枚举最终效果如下： enum Sex { BOY, GIRL; // 男，女 } // 枚举的本质是一个类，我们刚才定义的Sex枚举相当于下面的类 final class SEX extends java.lang.Enum&lt;SEX> { public static final SEX BOY = new SEX(); public static final SEX GIRL = new SEX(); public static SEX[] values(); public static SEX valueOf(java.lang.String); static {}; } 枚举的本质是一个类，所以枚举中还可以有成员变量，成员方法等。 public enum Sex { BOY(18), GIRL(16); public int age; Sex(int age) { this.age = age; } public void showAge() { System.out.println(\"年龄是: \" + age); } } public class Demo03 { public static void main(String[] args) { Person p1 = new Person(\"张三\", Sex.BOY); Person p2 = new Person(\"张三\", Sex.GIRL); Sex.BOY.showAge(); Sex.GIRL.showAge(); } } 6.4 应用场景6.5 枚举的应用枚举的作用：枚举通常可以用于做信息的分类，如性别，方向，季度等。 枚举表示性别： public enum Sex { MAIL, FEMAIL; } 枚举表示方向： public enum Orientation { UP, RIGHT, DOWN, LEFT; } 枚举表示季度 public enum Season { SPRING, SUMMER, AUTUMN, WINTER; } 6.6 小结 枚举类在第一行罗列若干个枚举对象。（多例） 第一行都是常量，存储的是枚举类的对象。 枚举是不能在外部创建对象的，枚举的构造器默认是私有的。 枚举通常用于做信息的标志和分类。","categories":[{"name":"java","slug":"java","permalink":"https://409713427.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://409713427.github.io/tags/java/"}],"author":"wst"},{"title":"Java基础 【继承，引用类型使用】","slug":"Java基础 【继承，引用类型使用】","date":"2021-09-17T12:02:32.000Z","updated":"2021-09-19T04:12:24.015Z","comments":true,"path":"2021/091736523.html","link":"","permalink":"https://409713427.github.io/2021/091736523.html","excerpt":"","text":"Java基础 【继承，引用类型使用】第一章 继承1.1 定义​ 继承就是子类继承父类的属性和行为，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为 1.2 继承的好处 1. 提高**代码的复用性**（减少代码冗余，相同代码重复利用）。 2. 使类与类之间产生了关系。 1.3 子类不能继承的内容1.3.1 引入并不是父类的所有内容都可以给子类继承的： 子类不能继承父类的构造器，因为子类有自己的构造器。 值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。 1.3.2 演示代码public class Demo03 { public static void main(String[] args) { Zi z = new Zi(); System.out.println(z.num1); // System.out.println(z.num2); // 私有的子类无法使用 // 通过getter/setter方法访问父类的private成员变量 System.out.println(z.getNum2()); z.show1(); // z.show2(); // 私有的子类无法使用 } } class Fu { public int num1 = 10; private int num2 = 20; public void show1() { System.out.println(\"show1\"); } private void show2() { System.out.println(\"show2\"); } public int getNum2() { return num2; } public void setNum2(int num2) { this.num2 = num2; } } class Zi extends Fu { } 小贴士：父类中的成员变量是非私有的，子类中可以直接访问。若父类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx()方法和setXxx()方法。 1.4 方法重写1.4.1 概念方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 1.4.2使用场景与案例发生在子父类之间的关系。子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方 法。 例如：我们定义了一个动物类代码如下： public class Animal { public void run(){ System.out.println(\"动物跑的很快！\"); } public void cry(){ System.out.println(\"动物都可以叫~~~\"); } } 然后定义一个猫类，猫可能认为父类cry()方法不能满足自己的需求 代码如下： public class Cat extends Animal { public void cry(){ System.out.println(\"我们一起学猫叫，喵喵喵！喵的非常好听！\"); } } public class Test { public static void main(String[] args) { // 创建子类对象 Cat ddm = new Cat()； // 调用父类继承而来的方法 ddm.run(); // 调用子类重写的方法 ddm.cry(); } } 1.4.3 @Override重写注解 @Override:注解，重写注解校验！ 这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。 建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！ 加上后的子类代码形式如下： public class Cat extends Animal { // 声明不变，重新实现 // 方法名称与父类全部一样，只是方法体中的功能重写写了！ @Override public void cry(){ System.out.println(\"我们一起学猫叫，喵喵喵！喵的非常好听！\"); } } 1.4.4 注意事项 方法重写是发生在子父类之间的关系。 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。 1.5 this与super 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。 super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 super(..)和this(…)是根据参数去确定调用父类哪个构造器的。 super(..)可以调用父类构造器初始化继承自父类的成员变量的数据。 this(..)可以调用本类中的其他构造器。 第二章 引用类型使用总结实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的。在这我们使用两个例子 , 来学习一下。 2.1 引用类型作为方法参数和返回值public class Person{ public void eat(){ System.out.println(\"吃饭\"); } } public class Test{ public static void main(String[] args){ method(new Person()); Person p = createPerson(); } //引用类型作为方法参数,在前面笔记本案例中我们也使用了接口类型作为方法参数 pubic static void method(Person p){ p.eat(); } //引用类型作为返回值 public static Person createPerson(){ return new Person(); } } 2.2 引用类型作为成员变量​ 我们每个人(Person)都有一个身份证(IDCard) , 为了表示这种关系 , 就需要在Person中定义一个IDCard的成员变量。定义Person类时，代码如下： class Person { String name;//姓名 int age;//年龄 } ​ 使用使用String 类型表示姓名 , int 类型表示年龄。其实，String本身就是引用类型，我们往往忽略了它是引用类型。如果我们继续丰富这个类的定义，给Person 增加身份证号 , 身份证签发机关等属性，我们将如何编写呢？这时候就需要编写一个IDCard类了 定义IDCard(身份证)类，添加身份证号 , 签发地等属性： class IDCard { String idNum;//身份证号 String authority;//签发地 //getter和setter方法 //... //toString方法 //... } 修改Person类： public class Person { String name;//姓名 int age;//年龄 IDCard idCard;//表示自己的身份证信息 //name和age的getter、setter方法 //... public IDCard getIdCard() { return idCard; } public void setIdCard(IDCard idCard) { this.idCard = idCard; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", idCard=\" + idCard + '}'; } } 测试类： public class TestDemo { public static void main(String[] args) { //创建IDCard对象 IDCard idCard = new IDCard(); //设置身份证号 idCard.setIdNum(\"110113201606066666\"); //设置签发地 idCard.setAuthority(\"北京市顺义区公安局\"); //创建Person对象 Person p = new Person(); //设置姓名 p.setName(\"小顺子\"); //设置年龄 p.setAge(2); //设置身份证信息 p.setIdCard(idCard); //打印小顺子的信息 System.out.println(p); } } 输出结果: Person{name='小顺子', age=2, idCard=IDCard{idNum='110113201606066666', authority='北京市顺义区公安局'}}","categories":[{"name":"java","slug":"java","permalink":"https://409713427.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://409713427.github.io/tags/java/"}],"author":"wst"},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-09-16T05:22:43.000Z","updated":"2021-09-17T05:48:05.769Z","comments":true,"path":"2021/091615650.html","link":"","permalink":"https://409713427.github.io/2021/091615650.html","excerpt":"我的博客文章编写","text":"我的博客文章编写 标题使用标题时候需要写# 这是第一个段落 这是第二个段落 区块引用 这是一段高亮显示 超链接 百度 图片","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-09-15T11:20:52.891Z","updated":"2021-09-16T09:35:37.612Z","comments":true,"path":"2021/091516107.html","link":"","permalink":"https://409713427.github.io/2021/091516107.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"javascript","slug":"javascript","permalink":"https://409713427.github.io/categories/javascript/"},{"name":"linux","slug":"linux","permalink":"https://409713427.github.io/categories/linux/"},{"name":"java","slug":"java","permalink":"https://409713427.github.io/categories/java/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://409713427.github.io/tags/javascript/"},{"name":"linux","slug":"linux","permalink":"https://409713427.github.io/tags/linux/"},{"name":"java","slug":"java","permalink":"https://409713427.github.io/tags/java/"}]}